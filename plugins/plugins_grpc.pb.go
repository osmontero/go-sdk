// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.1
// source: plugins.proto

package plugins

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Engine_Input_FullMethodName  = "/plugins.Engine/Input"
	Engine_Notify_FullMethodName = "/plugins.Engine/Notify"
)

// EngineClient is the client API for Engine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineClient interface {
	Input(ctx context.Context, opts ...grpc.CallOption) (Engine_InputClient, error)
	Notify(ctx context.Context, opts ...grpc.CallOption) (Engine_NotifyClient, error)
}

type engineClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineClient(cc grpc.ClientConnInterface) EngineClient {
	return &engineClient{cc}
}

func (c *engineClient) Input(ctx context.Context, opts ...grpc.CallOption) (Engine_InputClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[0], Engine_Input_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &engineInputClient{ClientStream: stream}
	return x, nil
}

type Engine_InputClient interface {
	Send(*Log) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type engineInputClient struct {
	grpc.ClientStream
}

func (x *engineInputClient) Send(m *Log) error {
	return x.ClientStream.SendMsg(m)
}

func (x *engineInputClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) Notify(ctx context.Context, opts ...grpc.CallOption) (Engine_NotifyClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[1], Engine_Notify_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &engineNotifyClient{ClientStream: stream}
	return x, nil
}

type Engine_NotifyClient interface {
	Send(*Message) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type engineNotifyClient struct {
	grpc.ClientStream
}

func (x *engineNotifyClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *engineNotifyClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EngineServer is the server API for Engine service.
// All implementations must embed UnimplementedEngineServer
// for forward compatibility
type EngineServer interface {
	Input(Engine_InputServer) error
	Notify(Engine_NotifyServer) error
	mustEmbedUnimplementedEngineServer()
}

// UnimplementedEngineServer must be embedded to have forward compatible implementations.
type UnimplementedEngineServer struct {
}

func (UnimplementedEngineServer) Input(Engine_InputServer) error {
	return status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedEngineServer) Notify(Engine_NotifyServer) error {
	return status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedEngineServer) mustEmbedUnimplementedEngineServer() {}

// UnsafeEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServer will
// result in compilation errors.
type UnsafeEngineServer interface {
	mustEmbedUnimplementedEngineServer()
}

func RegisterEngineServer(s grpc.ServiceRegistrar, srv EngineServer) {
	s.RegisterService(&Engine_ServiceDesc, srv)
}

func _Engine_Input_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Input(&engineInputServer{ServerStream: stream})
}

type Engine_InputServer interface {
	Send(*Ack) error
	Recv() (*Log, error)
	grpc.ServerStream
}

type engineInputServer struct {
	grpc.ServerStream
}

func (x *engineInputServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *engineInputServer) Recv() (*Log, error) {
	m := new(Log)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Engine_Notify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Notify(&engineNotifyServer{ServerStream: stream})
}

type Engine_NotifyServer interface {
	Send(*Ack) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type engineNotifyServer struct {
	grpc.ServerStream
}

func (x *engineNotifyServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *engineNotifyServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Engine_ServiceDesc is the grpc.ServiceDesc for Engine service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Engine_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Engine",
	HandlerType: (*EngineServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Input",
			Handler:       _Engine_Input_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Notify",
			Handler:       _Engine_Notify_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

const (
	Parsing_ParseLog_FullMethodName = "/plugins.Parsing/ParseLog"
)

// ParsingClient is the client API for Parsing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParsingClient interface {
	ParseLog(ctx context.Context, in *JLog, opts ...grpc.CallOption) (*JLog, error)
}

type parsingClient struct {
	cc grpc.ClientConnInterface
}

func NewParsingClient(cc grpc.ClientConnInterface) ParsingClient {
	return &parsingClient{cc}
}

func (c *parsingClient) ParseLog(ctx context.Context, in *JLog, opts ...grpc.CallOption) (*JLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JLog)
	err := c.cc.Invoke(ctx, Parsing_ParseLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParsingServer is the server API for Parsing service.
// All implementations must embed UnimplementedParsingServer
// for forward compatibility
type ParsingServer interface {
	ParseLog(context.Context, *JLog) (*JLog, error)
	mustEmbedUnimplementedParsingServer()
}

// UnimplementedParsingServer must be embedded to have forward compatible implementations.
type UnimplementedParsingServer struct {
}

func (UnimplementedParsingServer) ParseLog(context.Context, *JLog) (*JLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseLog not implemented")
}
func (UnimplementedParsingServer) mustEmbedUnimplementedParsingServer() {}

// UnsafeParsingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParsingServer will
// result in compilation errors.
type UnsafeParsingServer interface {
	mustEmbedUnimplementedParsingServer()
}

func RegisterParsingServer(s grpc.ServiceRegistrar, srv ParsingServer) {
	s.RegisterService(&Parsing_ServiceDesc, srv)
}

func _Parsing_ParseLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParsingServer).ParseLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Parsing_ParseLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParsingServer).ParseLog(ctx, req.(*JLog))
	}
	return interceptor(ctx, in, info, handler)
}

// Parsing_ServiceDesc is the grpc.ServiceDesc for Parsing service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Parsing_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Parsing",
	HandlerType: (*ParsingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ParseLog",
			Handler:    _Parsing_ParseLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Analysis_Analyze_FullMethodName = "/plugins.Analysis/Analyze"
)

// AnalysisClient is the client API for Analysis service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnalysisClient interface {
	Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Alert, error)
}

type analysisClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalysisClient(cc grpc.ClientConnInterface) AnalysisClient {
	return &analysisClient{cc}
}

func (c *analysisClient) Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Alert, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Alert)
	err := c.cc.Invoke(ctx, Analysis_Analyze_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnalysisServer is the server API for Analysis service.
// All implementations must embed UnimplementedAnalysisServer
// for forward compatibility
type AnalysisServer interface {
	Analyze(context.Context, *Event) (*Alert, error)
	mustEmbedUnimplementedAnalysisServer()
}

// UnimplementedAnalysisServer must be embedded to have forward compatible implementations.
type UnimplementedAnalysisServer struct {
}

func (UnimplementedAnalysisServer) Analyze(context.Context, *Event) (*Alert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Analyze not implemented")
}
func (UnimplementedAnalysisServer) mustEmbedUnimplementedAnalysisServer() {}

// UnsafeAnalysisServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalysisServer will
// result in compilation errors.
type UnsafeAnalysisServer interface {
	mustEmbedUnimplementedAnalysisServer()
}

func RegisterAnalysisServer(s grpc.ServiceRegistrar, srv AnalysisServer) {
	s.RegisterService(&Analysis_ServiceDesc, srv)
}

func _Analysis_Analyze_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalysisServer).Analyze(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Analysis_Analyze_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalysisServer).Analyze(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

// Analysis_ServiceDesc is the grpc.ServiceDesc for Analysis service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Analysis_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Analysis",
	HandlerType: (*AnalysisServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Analyze",
			Handler:    _Analysis_Analyze_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Correlation_Correlate_FullMethodName = "/plugins.Correlation/Correlate"
)

// CorrelationClient is the client API for Correlation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CorrelationClient interface {
	Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type correlationClient struct {
	cc grpc.ClientConnInterface
}

func NewCorrelationClient(cc grpc.ClientConnInterface) CorrelationClient {
	return &correlationClient{cc}
}

func (c *correlationClient) Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Correlation_Correlate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CorrelationServer is the server API for Correlation service.
// All implementations must embed UnimplementedCorrelationServer
// for forward compatibility
type CorrelationServer interface {
	Correlate(context.Context, *Alert) (*emptypb.Empty, error)
	mustEmbedUnimplementedCorrelationServer()
}

// UnimplementedCorrelationServer must be embedded to have forward compatible implementations.
type UnimplementedCorrelationServer struct {
}

func (UnimplementedCorrelationServer) Correlate(context.Context, *Alert) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Correlate not implemented")
}
func (UnimplementedCorrelationServer) mustEmbedUnimplementedCorrelationServer() {}

// UnsafeCorrelationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CorrelationServer will
// result in compilation errors.
type UnsafeCorrelationServer interface {
	mustEmbedUnimplementedCorrelationServer()
}

func RegisterCorrelationServer(s grpc.ServiceRegistrar, srv CorrelationServer) {
	s.RegisterService(&Correlation_ServiceDesc, srv)
}

func _Correlation_Correlate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorrelationServer).Correlate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Correlation_Correlate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorrelationServer).Correlate(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

// Correlation_ServiceDesc is the grpc.ServiceDesc for Correlation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Correlation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Correlation",
	HandlerType: (*CorrelationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Correlate",
			Handler:    _Correlation_Correlate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Notification_Notify_FullMethodName = "/plugins.Notification/Notify"
)

// NotificationClient is the client API for Notification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationClient interface {
	Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notificationClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationClient(cc grpc.ClientConnInterface) NotificationClient {
	return &notificationClient{cc}
}

func (c *notificationClient) Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Notification_Notify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServer is the server API for Notification service.
// All implementations must embed UnimplementedNotificationServer
// for forward compatibility
type NotificationServer interface {
	Notify(context.Context, *Message) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotificationServer()
}

// UnimplementedNotificationServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationServer struct {
}

func (UnimplementedNotificationServer) Notify(context.Context, *Message) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedNotificationServer) mustEmbedUnimplementedNotificationServer() {}

// UnsafeNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServer will
// result in compilation errors.
type UnsafeNotificationServer interface {
	mustEmbedUnimplementedNotificationServer()
}

func RegisterNotificationServer(s grpc.ServiceRegistrar, srv NotificationServer) {
	s.RegisterService(&Notification_ServiceDesc, srv)
}

func _Notification_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Notify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Notify(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

// Notification_ServiceDesc is the grpc.ServiceDesc for Notification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notification_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Notification",
	HandlerType: (*NotificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _Notification_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Integration_ProcessLog_FullMethodName = "/plugins.Integration/ProcessLog"
)

// IntegrationClient is the client API for Integration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntegrationClient interface {
	ProcessLog(ctx context.Context, opts ...grpc.CallOption) (Integration_ProcessLogClient, error)
}

type integrationClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegrationClient(cc grpc.ClientConnInterface) IntegrationClient {
	return &integrationClient{cc}
}

func (c *integrationClient) ProcessLog(ctx context.Context, opts ...grpc.CallOption) (Integration_ProcessLogClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Integration_ServiceDesc.Streams[0], Integration_ProcessLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &integrationProcessLogClient{ClientStream: stream}
	return x, nil
}

type Integration_ProcessLogClient interface {
	Send(*Log) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type integrationProcessLogClient struct {
	grpc.ClientStream
}

func (x *integrationProcessLogClient) Send(m *Log) error {
	return x.ClientStream.SendMsg(m)
}

func (x *integrationProcessLogClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IntegrationServer is the server API for Integration service.
// All implementations must embed UnimplementedIntegrationServer
// for forward compatibility
type IntegrationServer interface {
	ProcessLog(Integration_ProcessLogServer) error
	mustEmbedUnimplementedIntegrationServer()
}

// UnimplementedIntegrationServer must be embedded to have forward compatible implementations.
type UnimplementedIntegrationServer struct {
}

func (UnimplementedIntegrationServer) ProcessLog(Integration_ProcessLogServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessLog not implemented")
}
func (UnimplementedIntegrationServer) mustEmbedUnimplementedIntegrationServer() {}

// UnsafeIntegrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntegrationServer will
// result in compilation errors.
type UnsafeIntegrationServer interface {
	mustEmbedUnimplementedIntegrationServer()
}

func RegisterIntegrationServer(s grpc.ServiceRegistrar, srv IntegrationServer) {
	s.RegisterService(&Integration_ServiceDesc, srv)
}

func _Integration_ProcessLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IntegrationServer).ProcessLog(&integrationProcessLogServer{ServerStream: stream})
}

type Integration_ProcessLogServer interface {
	Send(*Ack) error
	Recv() (*Log, error)
	grpc.ServerStream
}

type integrationProcessLogServer struct {
	grpc.ServerStream
}

func (x *integrationProcessLogServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *integrationProcessLogServer) Recv() (*Log, error) {
	m := new(Log)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Integration_ServiceDesc is the grpc.ServiceDesc for Integration service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Integration_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Integration",
	HandlerType: (*IntegrationServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProcessLog",
			Handler:       _Integration_ProcessLog_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}
