// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: plugins.proto

package plugins

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Engine_Input_FullMethodName  = "/plugins.Engine/Input"
	Engine_Notify_FullMethodName = "/plugins.Engine/Notify"
)

// EngineClient is the client API for Engine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineClient interface {
	Input(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Log, Ack], error)
	Notify(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Message, Ack], error)
}

type engineClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineClient(cc grpc.ClientConnInterface) EngineClient {
	return &engineClient{cc}
}

func (c *engineClient) Input(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Log, Ack], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[0], Engine_Input_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Log, Ack]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Engine_InputClient = grpc.BidiStreamingClient[Log, Ack]

func (c *engineClient) Notify(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Message, Ack], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[1], Engine_Notify_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Message, Ack]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Engine_NotifyClient = grpc.BidiStreamingClient[Message, Ack]

// EngineServer is the server API for Engine service.
// All implementations must embed UnimplementedEngineServer
// for forward compatibility.
type EngineServer interface {
	Input(grpc.BidiStreamingServer[Log, Ack]) error
	Notify(grpc.BidiStreamingServer[Message, Ack]) error
	mustEmbedUnimplementedEngineServer()
}

// UnimplementedEngineServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEngineServer struct{}

func (UnimplementedEngineServer) Input(grpc.BidiStreamingServer[Log, Ack]) error {
	return status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedEngineServer) Notify(grpc.BidiStreamingServer[Message, Ack]) error {
	return status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedEngineServer) mustEmbedUnimplementedEngineServer() {}
func (UnimplementedEngineServer) testEmbeddedByValue()                {}

// UnsafeEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServer will
// result in compilation errors.
type UnsafeEngineServer interface {
	mustEmbedUnimplementedEngineServer()
}

func RegisterEngineServer(s grpc.ServiceRegistrar, srv EngineServer) {
	// If the following call pancis, it indicates UnimplementedEngineServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Engine_ServiceDesc, srv)
}

func _Engine_Input_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Input(&grpc.GenericServerStream[Log, Ack]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Engine_InputServer = grpc.BidiStreamingServer[Log, Ack]

func _Engine_Notify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Notify(&grpc.GenericServerStream[Message, Ack]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Engine_NotifyServer = grpc.BidiStreamingServer[Message, Ack]

// Engine_ServiceDesc is the grpc.ServiceDesc for Engine service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Engine_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Engine",
	HandlerType: (*EngineServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Input",
			Handler:       _Engine_Input_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Notify",
			Handler:       _Engine_Notify_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

const (
	Parsing_ParseLog_FullMethodName = "/plugins.Parsing/ParseLog"
)

// ParsingClient is the client API for Parsing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParsingClient interface {
	ParseLog(ctx context.Context, in *Transform, opts ...grpc.CallOption) (*Draft, error)
}

type parsingClient struct {
	cc grpc.ClientConnInterface
}

func NewParsingClient(cc grpc.ClientConnInterface) ParsingClient {
	return &parsingClient{cc}
}

func (c *parsingClient) ParseLog(ctx context.Context, in *Transform, opts ...grpc.CallOption) (*Draft, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Draft)
	err := c.cc.Invoke(ctx, Parsing_ParseLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParsingServer is the server API for Parsing service.
// All implementations must embed UnimplementedParsingServer
// for forward compatibility.
type ParsingServer interface {
	ParseLog(context.Context, *Transform) (*Draft, error)
	mustEmbedUnimplementedParsingServer()
}

// UnimplementedParsingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedParsingServer struct{}

func (UnimplementedParsingServer) ParseLog(context.Context, *Transform) (*Draft, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseLog not implemented")
}
func (UnimplementedParsingServer) mustEmbedUnimplementedParsingServer() {}
func (UnimplementedParsingServer) testEmbeddedByValue()                 {}

// UnsafeParsingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParsingServer will
// result in compilation errors.
type UnsafeParsingServer interface {
	mustEmbedUnimplementedParsingServer()
}

func RegisterParsingServer(s grpc.ServiceRegistrar, srv ParsingServer) {
	// If the following call pancis, it indicates UnimplementedParsingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Parsing_ServiceDesc, srv)
}

func _Parsing_ParseLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transform)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParsingServer).ParseLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Parsing_ParseLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParsingServer).ParseLog(ctx, req.(*Transform))
	}
	return interceptor(ctx, in, info, handler)
}

// Parsing_ServiceDesc is the grpc.ServiceDesc for Parsing service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Parsing_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Parsing",
	HandlerType: (*ParsingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ParseLog",
			Handler:    _Parsing_ParseLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Analysis_Analyze_FullMethodName = "/plugins.Analysis/Analyze"
)

// AnalysisClient is the client API for Analysis service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnalysisClient interface {
	Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Alert], error)
}

type analysisClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalysisClient(cc grpc.ClientConnInterface) AnalysisClient {
	return &analysisClient{cc}
}

func (c *analysisClient) Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Alert], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Analysis_ServiceDesc.Streams[0], Analysis_Analyze_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Event, Alert]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Analysis_AnalyzeClient = grpc.ServerStreamingClient[Alert]

// AnalysisServer is the server API for Analysis service.
// All implementations must embed UnimplementedAnalysisServer
// for forward compatibility.
type AnalysisServer interface {
	Analyze(*Event, grpc.ServerStreamingServer[Alert]) error
	mustEmbedUnimplementedAnalysisServer()
}

// UnimplementedAnalysisServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAnalysisServer struct{}

func (UnimplementedAnalysisServer) Analyze(*Event, grpc.ServerStreamingServer[Alert]) error {
	return status.Errorf(codes.Unimplemented, "method Analyze not implemented")
}
func (UnimplementedAnalysisServer) mustEmbedUnimplementedAnalysisServer() {}
func (UnimplementedAnalysisServer) testEmbeddedByValue()                  {}

// UnsafeAnalysisServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalysisServer will
// result in compilation errors.
type UnsafeAnalysisServer interface {
	mustEmbedUnimplementedAnalysisServer()
}

func RegisterAnalysisServer(s grpc.ServiceRegistrar, srv AnalysisServer) {
	// If the following call pancis, it indicates UnimplementedAnalysisServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Analysis_ServiceDesc, srv)
}

func _Analysis_Analyze_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Event)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnalysisServer).Analyze(m, &grpc.GenericServerStream[Event, Alert]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Analysis_AnalyzeServer = grpc.ServerStreamingServer[Alert]

// Analysis_ServiceDesc is the grpc.ServiceDesc for Analysis service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Analysis_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Analysis",
	HandlerType: (*AnalysisServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Analyze",
			Handler:       _Analysis_Analyze_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

const (
	Correlation_Correlate_FullMethodName = "/plugins.Correlation/Correlate"
)

// CorrelationClient is the client API for Correlation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CorrelationClient interface {
	Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type correlationClient struct {
	cc grpc.ClientConnInterface
}

func NewCorrelationClient(cc grpc.ClientConnInterface) CorrelationClient {
	return &correlationClient{cc}
}

func (c *correlationClient) Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Correlation_Correlate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CorrelationServer is the server API for Correlation service.
// All implementations must embed UnimplementedCorrelationServer
// for forward compatibility.
type CorrelationServer interface {
	Correlate(context.Context, *Alert) (*emptypb.Empty, error)
	mustEmbedUnimplementedCorrelationServer()
}

// UnimplementedCorrelationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCorrelationServer struct{}

func (UnimplementedCorrelationServer) Correlate(context.Context, *Alert) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Correlate not implemented")
}
func (UnimplementedCorrelationServer) mustEmbedUnimplementedCorrelationServer() {}
func (UnimplementedCorrelationServer) testEmbeddedByValue()                     {}

// UnsafeCorrelationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CorrelationServer will
// result in compilation errors.
type UnsafeCorrelationServer interface {
	mustEmbedUnimplementedCorrelationServer()
}

func RegisterCorrelationServer(s grpc.ServiceRegistrar, srv CorrelationServer) {
	// If the following call pancis, it indicates UnimplementedCorrelationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Correlation_ServiceDesc, srv)
}

func _Correlation_Correlate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorrelationServer).Correlate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Correlation_Correlate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorrelationServer).Correlate(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

// Correlation_ServiceDesc is the grpc.ServiceDesc for Correlation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Correlation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Correlation",
	HandlerType: (*CorrelationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Correlate",
			Handler:    _Correlation_Correlate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Notification_Notify_FullMethodName = "/plugins.Notification/Notify"
)

// NotificationClient is the client API for Notification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationClient interface {
	Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notificationClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationClient(cc grpc.ClientConnInterface) NotificationClient {
	return &notificationClient{cc}
}

func (c *notificationClient) Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Notification_Notify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServer is the server API for Notification service.
// All implementations must embed UnimplementedNotificationServer
// for forward compatibility.
type NotificationServer interface {
	Notify(context.Context, *Message) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotificationServer()
}

// UnimplementedNotificationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServer struct{}

func (UnimplementedNotificationServer) Notify(context.Context, *Message) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedNotificationServer) mustEmbedUnimplementedNotificationServer() {}
func (UnimplementedNotificationServer) testEmbeddedByValue()                      {}

// UnsafeNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServer will
// result in compilation errors.
type UnsafeNotificationServer interface {
	mustEmbedUnimplementedNotificationServer()
}

func RegisterNotificationServer(s grpc.ServiceRegistrar, srv NotificationServer) {
	// If the following call pancis, it indicates UnimplementedNotificationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Notification_ServiceDesc, srv)
}

func _Notification_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Notify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Notify(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

// Notification_ServiceDesc is the grpc.ServiceDesc for Notification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notification_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Notification",
	HandlerType: (*NotificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _Notification_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

const (
	Integration_ProcessLog_FullMethodName = "/plugins.Integration/ProcessLog"
)

// IntegrationClient is the client API for Integration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntegrationClient interface {
	ProcessLog(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Log, Ack], error)
}

type integrationClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegrationClient(cc grpc.ClientConnInterface) IntegrationClient {
	return &integrationClient{cc}
}

func (c *integrationClient) ProcessLog(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Log, Ack], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Integration_ServiceDesc.Streams[0], Integration_ProcessLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Log, Ack]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integration_ProcessLogClient = grpc.BidiStreamingClient[Log, Ack]

// IntegrationServer is the server API for Integration service.
// All implementations must embed UnimplementedIntegrationServer
// for forward compatibility.
type IntegrationServer interface {
	ProcessLog(grpc.BidiStreamingServer[Log, Ack]) error
	mustEmbedUnimplementedIntegrationServer()
}

// UnimplementedIntegrationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIntegrationServer struct{}

func (UnimplementedIntegrationServer) ProcessLog(grpc.BidiStreamingServer[Log, Ack]) error {
	return status.Errorf(codes.Unimplemented, "method ProcessLog not implemented")
}
func (UnimplementedIntegrationServer) mustEmbedUnimplementedIntegrationServer() {}
func (UnimplementedIntegrationServer) testEmbeddedByValue()                     {}

// UnsafeIntegrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntegrationServer will
// result in compilation errors.
type UnsafeIntegrationServer interface {
	mustEmbedUnimplementedIntegrationServer()
}

func RegisterIntegrationServer(s grpc.ServiceRegistrar, srv IntegrationServer) {
	// If the following call pancis, it indicates UnimplementedIntegrationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Integration_ServiceDesc, srv)
}

func _Integration_ProcessLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IntegrationServer).ProcessLog(&grpc.GenericServerStream[Log, Ack]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integration_ProcessLogServer = grpc.BidiStreamingServer[Log, Ack]

// Integration_ServiceDesc is the grpc.ServiceDesc for Integration service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Integration_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Integration",
	HandlerType: (*IntegrationServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProcessLog",
			Handler:       _Integration_ProcessLog_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

const (
	Output_EventOutput_FullMethodName = "/plugins.Output/EventOutput"
	Output_AlertOutput_FullMethodName = "/plugins.Output/AlertOutput"
)

// OutputClient is the client API for Output service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OutputClient interface {
	EventOutput(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AlertOutput(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type outputClient struct {
	cc grpc.ClientConnInterface
}

func NewOutputClient(cc grpc.ClientConnInterface) OutputClient {
	return &outputClient{cc}
}

func (c *outputClient) EventOutput(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Output_EventOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputClient) AlertOutput(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Output_AlertOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OutputServer is the server API for Output service.
// All implementations must embed UnimplementedOutputServer
// for forward compatibility.
type OutputServer interface {
	EventOutput(context.Context, *Event) (*emptypb.Empty, error)
	AlertOutput(context.Context, *Alert) (*emptypb.Empty, error)
	mustEmbedUnimplementedOutputServer()
}

// UnimplementedOutputServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOutputServer struct{}

func (UnimplementedOutputServer) EventOutput(context.Context, *Event) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventOutput not implemented")
}
func (UnimplementedOutputServer) AlertOutput(context.Context, *Alert) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlertOutput not implemented")
}
func (UnimplementedOutputServer) mustEmbedUnimplementedOutputServer() {}
func (UnimplementedOutputServer) testEmbeddedByValue()                {}

// UnsafeOutputServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OutputServer will
// result in compilation errors.
type UnsafeOutputServer interface {
	mustEmbedUnimplementedOutputServer()
}

func RegisterOutputServer(s grpc.ServiceRegistrar, srv OutputServer) {
	// If the following call pancis, it indicates UnimplementedOutputServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Output_ServiceDesc, srv)
}

func _Output_EventOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServer).EventOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Output_EventOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServer).EventOutput(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Output_AlertOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServer).AlertOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Output_AlertOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServer).AlertOutput(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

// Output_ServiceDesc is the grpc.ServiceDesc for Output service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Output_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Output",
	HandlerType: (*OutputServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EventOutput",
			Handler:    _Output_EventOutput_Handler,
		},
		{
			MethodName: "AlertOutput",
			Handler:    _Output_AlertOutput_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}
